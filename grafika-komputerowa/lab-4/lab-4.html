<!DOCTYPE html>
<head>
<meta charset="utf-8">
<script>
    var canvas;
    var graphics;

    function clearCanvas() {
        canvas = document.getElementById("canvas");
        if (!canvas.getContext) return;
        graphics = canvas.getContext("2d");
        graphics.clearRect(0, 0, canvas.width, canvas.height);
    }

    function line(a, b, style) {
        canvas = document.getElementById("canvas");
        if (!canvas.getContext) return;
        graphics = canvas.getContext("2d");
        graphics.beginPath();
        graphics.moveTo(a[0], a[1]);
        graphics.lineTo(b[0], b[1]);
        graphics.strokeStyle = style || "rgb(200, 0, 0)";
        graphics.stroke();
    }

    function projectXY(point, d, observer) {
        var projected = []
        projected[0] = (point[0] - observer[0]) * d / (d + point[2]) + observer[0];
        projected[1] = (point[1] - observer[1]) * d / (d + point[2]) + observer[1];
        return projected;
    }

    function line3d(a, b, style, d, observer) {
        line(projectXY(a, d, observer), projectXY(b, d, observer), style);
    }

    function degreeToRadian(angle) {
        return (Math.PI / 180) * angle;
    }

    var scale = 200;
    var cube = scaleXYZ([
        [1, 1, 1],
        [2, 1, 1],
        [2, 1, 2],
        [1, 1, 2],

        [1, 2, 1],
        [2, 2, 1],
        [2, 2, 2],
        [1, 2, 2]
    ], 200);
    var additional_vertices = scaleXYZ([[1.5, 0.5, 1.5], [1.5, 2.5, 1.5]], scale);

    var d = 700;
    var observer = [320, 240];

    function drawCube(vertices, scale, d, observer) {
        for(var i = 1; i < 4; i++)
            line3d(vertices[i - 1], vertices[i], "blue", d, observer);
        line3d(vertices[3], vertices[0], 'blue', d, observer);

        for (var i = 5; i < 8; i++)
            line3d(vertices[i - 1], vertices[i], "red", d, observer);
        line3d(vertices[7], vertices[4], 'red', d, observer);

        for (var i = 0; i < 4; i++)
            line3d(vertices[i], vertices[i + 4], "green", d, observer);

        draw_additional_vertices();
    }

    function draw_additional_vertices() {
        for(var i = 0; i < 4; i++) line3d(cube[i], additional_vertices[0], 'purple', d, observer);
        for(var i = 4; i < 8; i++) line3d(cube[i], additional_vertices[1], 'purple', d, observer);
    }

    function scaleXYZ(vertices, scale) {
        for(var j = 0; j < vertices.length; j++)
            for (var i = 0; i < 3; i++) vertices[j][i] *= scale;
        return vertices;
    }

    // rotate around the axis parellel to the X axis and crossing point q
    function rotateX(p, q, angle) {
        var rotateAngle = degreeToRadian(angle);
        var p_y = p[1];

        p[1] = (p[1] - q[1]) * Math.cos(rotateAngle) - (p[2] - q[2]) * Math.sin(rotateAngle) + q[1];
        p[2] = (p_y - q[1]) * Math.sin(rotateAngle) + (p[2] - q[2]) * Math.cos(rotateAngle) + q[2];
        return p;
    }

    // rotate around the axis parallel to the Y axis and crossing point q
    function rotateY(p, q, angle) {
        var rotateAngle = degreeToRadian(angle);
        var p_x = p[0];

        p[0] = (p[0] - q[0]) * Math.cos(rotateAngle) - (p[2] - q[2]) * Math.sin(rotateAngle) + q[0];
        p[2] = (p_x - q[0]) * Math.sin(rotateAngle) + (p[2] - q[2]) * Math.cos(rotateAngle) + q[2];
        return p;
    }

    // rotate around the axis parallel to the Z axis and crossing point q
    function rotateZ(p, q, angle) {
        var rotateAngle = degreeToRadian(angle);
        var p_x = p[0];

        p[0] = (p[0] - q[0]) * Math.cos(rotateAngle) - (p[1] - q[1]) * Math.sin(rotateAngle) + q[0];
        p[1] = (p_x - q[0]) * Math.sin(rotateAngle) + (p[1] - q[1]) * Math.cos(rotateAngle) + q[1];
        return p;
    }

    function getCubeMiddle(vertices) {
        var middle = [];
        middle[0] = (vertices[0][0] + vertices[6][0]) / 2;
        middle[1] = (vertices[0][1] + vertices[6][1]) / 2;
        middle[2] = (vertices[0][2] + vertices[6][2]) / 2;
        return middle;
    }

    function rotateCubeX(scale, d, observer) {
        var angle = 6;
        var middle = getCubeMiddle(cube);
        for (var i = 0; i < cube.length; i++) rotateX(cube[i], middle, angle);
        for (var i = 0; i < additional_vertices.length; i++) rotateX(additional_vertices[i], middle, angle);
        clearCanvas();
        drawCube(cube, scale, d, observer);
    }

    function rotateCubeY(scale, d, observer) {
        var angle = 6;
        var middle = getCubeMiddle(cube);
        for (var i = 0; i < cube.length; i++) rotateY(cube[i], middle, angle);
        for (var i = 0; i < additional_vertices.length; i++) rotateY(additional_vertices[i], middle, angle);
        clearCanvas();
        drawCube(cube, scale, d, observer);
    }

    function rotateCubeZ(scale, d, observer) {
        var angle = 6;
        var middle = getCubeMiddle(cube);
        for (var i = 0; i < cube.length; i++) rotateZ(cube[i], middle, angle);
        for (var i = 0; i < additional_vertices.length; i++) rotateZ(additional_vertices[i], middle, angle);
        clearCanvas();
        drawCube(cube, scale, d, observer);
    }

    // animations
    var aniX, aniY, aniZ;
    function stopAnimation() {
        clearInterval(aniX);
        clearInterval(aniY);
        clearInterval(aniZ);
    }
    function startAniX() {
        stopAnimation();
        aniX = setInterval("rotateCubeX(scale, d, observer)", 50);
    }
    function startAniY() {
        stopAnimation();
        aniY = setInterval("rotateCubeY(scale, d, observer)", 50);
    }
    function startAniZ() {
        stopAnimation();
        aniZ = setInterval("rotateCubeZ(scale, d, observer)", 50);
    }

    // focal changes
    function changeFocal(delta) {
        if (d > 100 && d < 3000) d += delta;
        clearCanvas();
        drawCube(cube, scale, d, observer);
    }

    // translations
    function translate(point, change) {
        for (var i = 0; i < point.length; i++) point[i] += change[i];
        return point;
    }

    function translateCube(change) {
        for (var i = 0; i < cube.length; i++) translate(cube[i], change);
        for (var i = 0; i < additional_vertices.length; i++) translate(additional_vertices[i], change);
        clearCanvas();
        drawCube(cube, scale, d, observer);
    }

    // Handle key presses
    function handleKeyUp(keypress) {
        stopAnimation();
        keypress = keypress || event;
        var keyCode = keypress.keyCode;

        switch(keyCode) {
            case 37:
                translateCube([-10, 0, 0]);
                break;
            case 38:
                translateCube([0, -10, 0]);
                break;
            case 39:
                translateCube([10, 0, 0]);
                break;
            case 40:
                translateCube([0, 10, 0]);
                break;
            default:
                break;
        }
    }
</script>
</head>

<body onkeyup = "handleKeyUp(event)">
    <canvas id = "canvas" width = 600 height = 600>Browser does not support canvas</canvas>
    <br>
    <button id = "clear" onclick = "clearCanvas()">Clear canvas</button>
    <button id = "draw-cube" onclick = "drawCube(cube, scale, d, observer)">Draw cube</button>
    <button id ="line-test" onclick = "line3d([1, 1,], [50, 50], 'blue', d, observer)">Draw test line</button>
    <button id = "rotateX" onclick = "startAniX()">Rotate around OX</button>
    <button id = "rotateY" onclick = "startAniY()">Rotate around OY</button>
    <button id = "rotateZ" onclick = "startAniZ()">Rotate around OZ</button>
    <button id = "stop-animation" onclick = "stopAnimation()">Stop rotations</button>
    <button id = "focal-close" onclick = "changeFocal(50)">Zoom in</button>
    <button id = "focal-far" onclick = "changeFocal(-50)">Zoom out</button>
</body>
